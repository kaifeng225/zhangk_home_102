package com.example.springboot.mapstruct.converter.demo;

import org.mapstruct.InheritConfiguration;
import org.mapstruct.InheritInverseConfiguration;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import com.example.springboot.mapstruct.domain.Car;
import com.example.springboot.mapstruct.domain.CarDto;

/**
 * To generate a mapper for creating a CarDto object out of a Car object, a mapper interface needs to be defined:
 * The @Mapper annotation marks the interface as mapping interface and lets the MapStruct processor kick in during compilation.
 * 
 * @author rzhang2
 *
 */
@Mapper
public interface CarMapper {
 
	/**
	 * An instance of the interface implementation can be retrieved from the Mappers class. 
	 * By convention, the interface declares a member INSTANCE, providing clients access to the mapper implementation.
	 */
    CarMapper INSTANCE = Mappers.getMapper( CarMapper.class );
 
    /**
     * The actual mapping method expects the source object as parameter and returns the target object. Its name can be freely chosen.
     * For attributes with different names in source and target object, the @Mapping annotation can be used to configure the names.
     * @param car
     * @return
     */
    @Mapping(source = "numberOfSeats", target = "seatCount")
    CarDto carToCarDto(Car car);
    
    /**
     * Of course there can be multiple mapping methods in one interface, for all of which an implementation will be generated by MapStruct.
     */
    
    /**
     * Mapping configuration inheritance
     * Method-level configuration annotations such as @Mapping, @BeanMapping, @IterableMapping, 
     * etc., can be inherited from one mapping method to a similar method using the annotation @InheritConfiguration
     */
    /**
     * In case of bi-directional mappings, e.g. from entity to DTO and from DTO to entity, the mapping rules for the forward method 
     * and the reverse method are often similar and can simply be inversed by switching source and target.
     * Use the annotation @InheritInverseConfiguration to indicate that a method shall inherit the inverse
     * configuration of the corresponding reverse method.
     * @return
     */
    @InheritInverseConfiguration
    @Mapping(source = "createBy", target = "createBy" ,ignore = true)
    Car carDtoToCar(CarDto carDto);
    
    @InheritConfiguration
    void carDtoIntoCar(CarDto carDto, @MappingTarget Car car);
    
}